---
marp: true
theme: gaia
_class: lead
paginate: true

backgroundColor: #fff
backgroundImage: url('https://marp.app/assets/hero-background.svg')
---

 # 信頼性設計入門

---
 ##  目次
 - 信頼性とは
 - 信頼性確保の方法
 - 冗長化方式
 - レジリエンシーの確保
 - 障害復旧時間の短縮
  

---
## 信頼性とは
- 信頼性とは、可用性と並んで評価されるシステムやそのコンポーネントがどれだけ期待通り利用できるか。
  - 障害などで使えない状態の時間を極力短くすること
- 障害は必ず発生する。機器は壊れる/NWは途切れる
 - 設定やプログラムにバグがある場合もあるし、バグがない場合でも必ず障害は発生する
   - AWSでも中身は物理的なコンピュータが動いている。そこでも必ず障害はある  
---
# 信頼性とは
 - 稼働率などで示される
   - 99% -> 年間87時間障害停止
   - 99.9％ -> 年間 8.7時間障害停止
   - 99.99％ -> 年間52.56分障害停止
   - 99.999% -> 年間５分障害停止
 - どこを目指すか

---
## 信頼性確保の方式
<style scoped>
section {
  font-size: 24px;
}

</style>
 1. 信頼性の高いコンポーネントやサービスを使う
    - メインフレームなどは機器故障による障害発生確率は低い/内部が冗長化されている 
    - Route53/S3などのグローバルサービスは内部で冗長化されており、信頼性が高い
 2. 冗長化
    - コンポーネントを2重化/多重化する。切り替えの方式により切り替え時間が異なる
    - オンプレとクラウドで方式が異なる
 3. レジリエンシー   
    - 環境変化に対して自動で適応して自動で復旧する仕組み
    - 自動リスタート/auto-scaling/流量制限/サーキットブレーカー/自動リトライなど

---
<!-- _class: lead -->
# 冗長化方式

--- 
## 冗長化方式の原則
<style scoped>
section {
  font-size: 28px;
}

</style>
- 製品を作る人たちでない我々が考えるのは基本的にサーバの冗長化
- 同じ役割の複数のサーバを利用する。
 - データをどこに持つかで考慮することが変わる
   - Webサーバ
     - 原則サーバにデータは持たず、考慮するのはログの集約など
   - APサーバ
     - 一部の永続情報(セッション情報)などをどうするのか
   - DBサーバ/データストア
     - ミドルウェア毎に利用できる方式が異なる。
   - バッチ/メッセージキューを処理するworker
     - 2重実行をどう防ぐのか。リトライによって冗長性を確保する

--- 
## Webサーバの冗長化
- ロードバランサを使って冗長化が原則
  - WebサーバはAWSではALBやcloudfrontがその役割を担うのでシンプルな構成だとなくせる。
  - k8s/eksではIngress controllerがWebサーバ
  - 冗長化されたサーバが全て動作するactive-activeが原則。片系障害時には縮退運用となる
---
## Webサーバの冗長化-オンプレとAWSの違い
  - オンプレでは信頼性の高いコンポーネントであるLBは一つが原則/配線の冗長化などはするが。そのため、IPは一つであり、クライアントはLBを意識するので冗長化を意識しない
  - AWSではロードバランサーはAZ毎に一つあり、LB自体が冗長化されている。AZ冗長化に対応するにはクライアント側はDNSを使うなどしてIPを切り替える必要がある。背後のサーバ冗長化だけを求めるなら実は固定のLBを指定してもよい。（原則ダメ）
    - JavaなどのアプリケーションによってはDNSキャッシュを起動時に取得したまま使い続ける場合があるのでDNSキャッシュのTTLは短く設定する

---
## APサーバの冗長化
- LB-Webサーバ(ALB)の後ろに配置
  - オンプレの場合はwebサーバとセットで冗長化される。フロントのwebサーバが障害を起こすとapサーバも使えなくなる
- APサーバはユーザーのセッション情報などをどのように持つか、が鍵
  -  アクセストークンなどを検証してユーザー情報はDBにリクエスト毎/持ち回り系の情報はフロントのブラウザで保持する方法もあるが、Springや通常のWebアプリではcookieを使ったセッションの方が一般的ではある。アクセストークン方式はトークンの検証などの方式を検討する必要がある。
---
## APサーバの冗長化-セッション情報の扱い
- スティッキーセッション
  - LBの機能にあるstiky-sessionは同じセッションのリクエストは同じサーバに送る設定。サーバ障害時/再起動時などはセッションが切れる
- セッションストア
  - redisやDBなどにセッション情報を格納する
- セッションレプリケーション
  - 商用APサーバなどはセッションを冗長化したサーバにレプリケーションする機能がある

--- 
## LBを使った場合の切り替え
- LBからhealthチェックによって死活監視を行う
  - healthyだと返すロジックはどうするか。単純にサーバが生きていればOKとするかDBなどとの疎通まで見るか。->原則サーバ生きていればで良い。DBなどは短時間で復旧するので。

--- 
## DBサーバの冗長化
- 通常のDBMS(分散DBやOracleRACではない)では原則書き込みの不整合を避けるため、書き込みサーバは一つ。active-stanby方式
- オンプレとAWS RDSなどとの冗長化方式は異なる。EC2でオンプレ方式での冗長化を行なっている場合もある。

--- 
## オンプレDBサーバの冗長化
- クラスタリングソフトウェアをサーバに入れて、仮想IPをクライアントに公開し、切り替え時にクライアントにIP変更を意識させない方式をとる
- 共有Disk方式
 - 信頼性の高いストレージサーバを使い、データを保存するサーバは共有ストレージに格納。
- レプリケーション方式
 - データを保存するディスクも冗長化する。ディスクのコストが上がる。

--- 
## クラウドDBの冗長化
- レプリケーションサーバを複数台たてるが、AZ跨ぎなどもあるため、IPも切り替え時には変更される。
- LBと同じくDNSキャッシュなどを考慮する必要がある
- postgresqlではJDBCドライバーの機能で切り替えができる。
- AWSが冗長化に対応したドライバーを提供してはいる

---
<!-- _class: lead -->
# レジリエンシーの確保
---
# レジリエンスとは
<style scoped>
section {
  font-size: 28px;
}

</style>
- 回復力。環境変化に対応する力のこと
  - システムが環境変化に対応して(自動で)稼働しつづける仕組み
- 自動復旧
  - EC2/コンテナタスクやpodはサーバダウンしたとき自動で復旧する
---
# レジリエンス実現方式
<style scoped>
section {
  font-size: 28px;
}
</style>
- オートスケール
  - メトリクスによってサーバ台数を増やすことで負荷増大による障害を防ぐ
- 流量制限
  - 許容量を超えた流量に対してエラーをかえし、システム停止を防ぐ。オートスケールがメトリクスの設計やスケールに時間がかかるため流量制限は有効。
  -  色々な方式がある
- サーキットブレーカー
  - 連携システムが障害は発生した場合、切り離すことでその他機能を守る
- 自動リトライ  
  - 処理の冪等性を確保する必要がある
- route53でのhealth checkやALBのエラー時切り離しなど。

---
<!-- _class: lead -->
# 障害復旧時間の短縮

---
## 運用改善で短縮できる
- リリース/変更時の障害発生を防ぐ
  - 切り戻し手順
  - blue/greenデプロイ/カナリアリリース

- 障害発生時の調査と対応
  - 監視/ログ/アラート/通知方法